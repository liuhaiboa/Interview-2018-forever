#数据结构和算法
##第一部分：极客时间学习笔记
摘要：     极客时间版权所有: https://time.geekbang.org/column/article/40036
10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、、跳表、图、Trie 树；
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
     [数据结构图](https://time.geekbang.org/column/article/40011)    
####第一章：时间、空间复杂度分析
 #####1.1  大 O 复杂度表示法
  ######1.1.1 时间复杂度
  所有代码的执行时间 T(n) 与每行代码的执行次数成正比。T(n)=O(f(n))
  大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐近时间复杂度. 
  - 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
  - 加法法则：总复杂度等于量级最大的那段代码的复杂度
  - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  - 又分为：
    - 最好情况时间复杂度、 
    - 最坏情况时间复杂度、 
    - 平均情况时间复杂度（代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示）
    - 均摊时间复杂度（在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度）。
  1. O(1):一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
  2. O(logn),O(nlogn):在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n))=O(f(n))。O(log2n)就等于O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。
  3. O(m+n)、O(m*n): 
   
```
   i=1; while (i <= n) { i = i * 2; }
   我们要计算出i=i*2代码执行了多少次，得出时间复杂度。通过 2x=n求解x。x=log2n，所以，这段代码的时间复杂度就是O(log2n)。
   i=1; while (i <= n) { i = i * 3; }  这段代码时间复杂度是O(log3n)。log3n 就等于 log32 * log2n。所以所以 O(log3n) = O(C * log2n)，统一表示为O（logn）。
   我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是。
   int cal(int m, int n) {  int sum_1 = 0; int i = 1;for (; i < m; ++i) {sum_1 = sum_1 + i; }
                            int sum_2 = 0; int j = 1;for (; j < n; ++j) {sum_2 = sum_2 + j; }
                              return sum_1 + sum_2;
                          }
   m 和 n 是表示两个数据规模,我们无法事先评估 m 和 n 谁的量级大,所以，上面代码的时间复杂度就是 O(m+n)。
   针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n)).但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。                                           
```
  ######1.1.2 空间复杂度
  渐进空间复杂度（AsymptoticSpacecComplexity）表示算法的存储空间与数据规模之间的增长关系
  常见的空间复杂度就是 O(1)、O(n)、O(n2 )，                 
####第二章：数组：为什么很多编程语言中数组都从0开始编号？
 #####1.1 几个概念：
   数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
   线性表（LinearList）线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，数组，链表、队列、栈等都是线性表结构
   非线性表，比如二叉树、堆、图等。数据之间并不是简单的前后关系。
 #####1.2 数组如何实现根据下标随机访问数组元素
   数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。                    
   一个长度为10的int类型的数组int[]a=newint[10]计算机给数组a[10]分配了一块连续内存空间1000～1039。内存块的首地址为base_address=1000。a[0]对应1000~1003。
   计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。计算机需要随机访问数组中的某个元素时，它会首先通过a[i]_address=base_address+i*data_type_size（数组中每个元素的大小）寻址公式计算出该元素存储的内存地址。比如数组中存储的是int类型，所以 data_type_size就4个字节
   数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。
####第三章：链表：如何实现LRU缓存淘汰算法?最近最少使用策略 LRU（Least Recently Used）
 #####1.1 几个概念：
   链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。链表结构：单链表、双向链表和循环链表
   我们把内存块称为链表的“结点”。为将所有的结点串起来每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址的指针叫作后继指针next。
   在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以在链表中插入和删除一个数据是非常快速的。
   链表要想随机访问第 k 个元素，就没有数组那么高效了
   <div align="center"> <img src="pic/d5d5bee4be28326ba3c28373808a62cd.jpg" width=""/> </div><br>

    
                   
                  
    
   
                                    
                                

##第二部分：面试宝典算法题