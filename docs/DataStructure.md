# 数据结构和算法
<!-- GFM-TOC -->
* [一、极客时间学习笔记](#一极客时间学习笔记)
    * [时间、空间复杂度分析](#时间、空间复杂度分析)
* [二、面试宝典算法题](#二面试宝典算法题)

<!-- GFM-TOC -->

# 一、极客时间学习笔记
摘要：     极客时间版权所有: https://time.geekbang.org/column/article/40036
10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、、跳表、图、Trie 树；
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
     [数据结构图](https://time.geekbang.org/column/article/40011)  
       
## 时间、空间复杂度分析

##### 1.1  大 O 复杂度表示法
###### 1.1.1 时间复杂度
所有代码的执行时间 T(n) 与每行代码的执行次数成正比。T(n)=O(f(n))
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐近时间复杂度. 
- 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
- 又分为:  最好情况时间复杂度、  最坏情况时间复杂度、  平均情况时间复杂度（代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示）  均摊时间复杂度（在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度）。
1. O(1):一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. O(logn),O(nlogn):在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n))=O(f(n))。O(log2n)就等于O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。
3. O(m+n)、O(m*n): 
   
```
   i=1; while (i <= n) { i = i * 2; }
   我们要计算出i=i*2代码执行了多少次，得出时间复杂度。通过 2x=n求解x。x=log2n，所以，这段代码的时间复杂度就是O(log2n)。
   i=1; while (i <= n) { i = i * 3; }  这段代码时间复杂度是O(log3n)。log3n 就等于 log32 * log2n。所以所以 O(log3n) = O(C * log2n)，统一表示为O（logn）。
   我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是。
   int cal(int m, int n) {  int sum_1 = 0; int i = 1;for (; i < m; ++i) {sum_1 = sum_1 + i; }
                            int sum_2 = 0; int j = 1;for (; j < n; ++j) {sum_2 = sum_2 + j; }
                              return sum_1 + sum_2;
                          }
   m 和 n 是表示两个数据规模,我们无法事先评估 m 和 n 谁的量级大,所以，上面代码的时间复杂度就是 O(m+n)。
   针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n)).但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。                                           
```
###### 1.1.2 空间复杂度
渐进空间复杂度（AsymptoticSpacecComplexity）表示算法的存储空间与数据规模之间的增长关系。  
常见的空间复杂度就是 O(1)、O(n)、O(n2 )。                 
#### 第二章：数组：为什么很多编程语言中数组都从0开始编号？
##### 1.1 几个概念：
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。   
线性表（LinearList）线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，数组，链表、队列、栈等都是线性表结构。   
非线性表，比如二叉树、堆、图等。数据之间并不是简单的前后关系。
##### 1.2 数组如何实现根据下标随机访问数组元素
数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。                    
一个长度为10的int类型的数组int[]a=newint[10]计算机给数组a[10]分配了一块连续内存空间1000～1039。内存块的首地址为base_address=1000。a[0]对应1000~1003。  
计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。计算机需要随机访问数组中的某个元素时，它会首先通过a[i]_address=base_address+i*data_type_size（数组中每个元素的大小）寻址公式计算出该元素存储的内存地址。比如数组中存储的是int类型，所以 data_type_size就4个字节。  
数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。
#### 第三章：链表：
##### 1.1 几个概念：
链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。  
链表结构：单链表、双向链表和循环链表。   
我们把内存块称为链表的“结点”。为将所有的结点串起来每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址的指针叫作后继指针next。   
在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以在链表中插入和删除一个数据是非常快速的。    
链表要想随机访问第 k 个元素，就没有数组那么高效了，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。   
 <div align="center"> <img src="pic/d5d5bee4be28326ba3c28373808a62cd.jpg" width=""/> </div><br>
循环链表是一种特殊的单链表，它跟单链表唯一的区别就在尾结点，单链表的尾结点指针指向空地址，循环链表的尾结点指针是指向链表的头结点。   
循环链表的优点是从链尾到链头比较方便。   
双向链表：它支持两个方向，每个结点还有一个前驱指针prev指向前面的结点。  
 <div align="center"> <img src="pic/cbc8ab20276e2f9312030c313a9ef70b.jpg" width=""/> </div><br>  
                
##### 1.2 如何实现LRU缓存淘汰算法?最近最少使用策略 LRU（Least Recently Used）           
我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。   
如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 
如果此数据没有在缓存链表中，又可以分为两种情况：   
如果此时缓存未满，则将此结点直接插入到链表的头部；   
如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。                 
  
##### 1.3 如何正确的写出链表代码?
1. 技巧一：理解指针或引用的含义 
指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。p->next=q。这行代码是说,p结点中的next指针存储了q结点的内存地址。
2. 技巧二：警惕指针丢失和内存泄漏 
插入结点时，一定要注意操作的顺序，先保存指针指向。删除链表结点时，也一定要记得手动释放内存空间
3. 技巧三：利用哨兵简化实现难度 
引入哨兵结点不存储数据，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。 这个可以是一些资料深入理解
4. 技巧四：重点留意边界条件处理 
比如： 链表是否为空， 只包含一个，两个节点，处理的头结点，尾节点 。 
5. 多画图，多看题
练习题LeetCode对应编号：206，141，21，19，876                                 
#### 第四章：栈：如何实现浏览器的前进和后退功能？
后进者先出，先进者后出，这就是典型的“栈”结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。                                                                                                                                                                 
栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
 ````
     // 基于数组实现的顺序栈
     public class ArrayStack {
       private String[] items;  // 数组
       private int count;       // 栈中元素个数
       private int n;           // 栈的大小     
       // 初始化数组，申请一个大小为 n 的数组空间
       public ArrayStack(int n) {
         this.items = new String[n];
         this.n = n;
         this.count = 0;
       }
       // 入栈操作
       public boolean push(String item) {
         // 数组空间不够了，直接返回 false，入栈失败。
         if (count == n) return false;
         // 将 item 放到下标为 count 的位置，并且 count 加一
         items[count] = item;
         ++count;
         return true;
       } 
       // 出栈操作
       public String pop() {
         // 栈为空，则直接返回 null
         if (count == 0) return null;
         // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
         String tmp = items[count-1];
         --count;
         return tmp;
       }
     }
```` 
 栈在函数调用中的应用：  
 我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。  
 栈在表达式求值中的应用：  
 编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。  
 我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  
 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数然后进行计算，再把计算完的结果压入操作数栈，继续比较。
                                                                                                                                                                         
 #### 第五章：队列
 队列是先进先出的数据结构。入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列
 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据。
 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原...
 队列可以在线程池中使用。。。具体不同的使用方式在线程池分析                                                                                         
                                                          
 #### 第六章：递归：如何用三行代码找到“最终推荐人”？                           
推荐注册返佣金的这个功能：用户A推荐用户B来注册，用户B又推荐了用户C来注册。用户C的“最终推荐人”为用户A，用户B的“最终推荐人为A。
很多地方都会用到递归思想：比如 DFS 深度优先搜索、前中后序二叉树遍历等。  
递归需要满足的三个条件：1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件
写递归代码最关键的是写出递推公式，找到终止条件。  
````$xslt
例子：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？
可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，，n-2 个台阶的走法。  
递归公式就是：f(n) = f(n-1)+f(n-2)
递归终止条件：f(1) = 1;
            f(2) = 2;
最终递归代码：
       int f(int n) {
         if (n == 1) return 1;
         if (n == 2) return 2;
         return f(n-1) + f(n-2);
       } 
````
 所以：找到最终推荐人：
  ````$xslt
long findRootReferrerId(long actorId) {
  Long referrerId = select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}

````                 
 #### 第七章：排序                                             
  <div align="center"> <img src="pic/sort.jpg" width=""/> </div><br>
                                     
1 [排序算法](https://github.com/princesslhb/Interview-2018-forever/blob/master/docs/data/排序.md)
                                                                      
 <div align="center"> <img src="pic/allsort.jpg" width=""/> </div><br>                                   
排序算法优化：  
                                    
 1. 如何优化快速排序？
 2.    
   

# 二、面试宝典算法题
### 第一部分 链表
````
链表结构:class Node{
                 Node next =null;
                 int data;
                 public Node(int data){this.data=data;}
}
````
1 [单链表的操作](https://github.com/princesslhb/Interview-2018-forever/blob/master/docs/data/链表.md)

 
 

