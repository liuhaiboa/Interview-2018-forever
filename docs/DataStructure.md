# 数据结构和算法
## 第一部分：极客时间学习笔记
摘要：     极客时间版权所有: https://time.geekbang.org/column/article/40036
10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、、跳表、图、Trie 树；
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
     [数据结构图](https://time.geekbang.org/column/article/40011)    
#### 第一章：时间、空间复杂度分析
##### 1.1  大 O 复杂度表示法
###### 1.1.1 时间复杂度
所有代码的执行时间 T(n) 与每行代码的执行次数成正比。T(n)=O(f(n))
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐近时间复杂度. 
- 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
- 又分为:  最好情况时间复杂度、  最坏情况时间复杂度、  平均情况时间复杂度（代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示）  均摊时间复杂度（在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度）。
1. O(1):一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. O(logn),O(nlogn):在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n))=O(f(n))。O(log2n)就等于O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。
3. O(m+n)、O(m*n): 
   
```
   i=1; while (i <= n) { i = i * 2; }
   我们要计算出i=i*2代码执行了多少次，得出时间复杂度。通过 2x=n求解x。x=log2n，所以，这段代码的时间复杂度就是O(log2n)。
   i=1; while (i <= n) { i = i * 3; }  这段代码时间复杂度是O(log3n)。log3n 就等于 log32 * log2n。所以所以 O(log3n) = O(C * log2n)，统一表示为O（logn）。
   我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是。
   int cal(int m, int n) {  int sum_1 = 0; int i = 1;for (; i < m; ++i) {sum_1 = sum_1 + i; }
                            int sum_2 = 0; int j = 1;for (; j < n; ++j) {sum_2 = sum_2 + j; }
                              return sum_1 + sum_2;
                          }
   m 和 n 是表示两个数据规模,我们无法事先评估 m 和 n 谁的量级大,所以，上面代码的时间复杂度就是 O(m+n)。
   针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n)).但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。                                           
```
###### 1.1.2 空间复杂度
渐进空间复杂度（AsymptoticSpacecComplexity）表示算法的存储空间与数据规模之间的增长关系。  
常见的空间复杂度就是 O(1)、O(n)、O(n2 )。                 
#### 第二章：数组：为什么很多编程语言中数组都从0开始编号？
##### 1.1 几个概念：
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。   
线性表（LinearList）线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，数组，链表、队列、栈等都是线性表结构。   
非线性表，比如二叉树、堆、图等。数据之间并不是简单的前后关系。
##### 1.2 数组如何实现根据下标随机访问数组元素
数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。                    
一个长度为10的int类型的数组int[]a=newint[10]计算机给数组a[10]分配了一块连续内存空间1000～1039。内存块的首地址为base_address=1000。a[0]对应1000~1003。  
计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。计算机需要随机访问数组中的某个元素时，它会首先通过a[i]_address=base_address+i*data_type_size（数组中每个元素的大小）寻址公式计算出该元素存储的内存地址。比如数组中存储的是int类型，所以 data_type_size就4个字节。  
数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。
#### 第三章：链表：
##### 1.1 几个概念：
链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。  
链表结构：单链表、双向链表和循环链表。   
我们把内存块称为链表的“结点”。为将所有的结点串起来每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址的指针叫作后继指针next。   
在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以在链表中插入和删除一个数据是非常快速的。    
链表要想随机访问第 k 个元素，就没有数组那么高效了，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。   
 <div align="center"> <img src="pic/d5d5bee4be28326ba3c28373808a62cd.jpg" width=""/> </div><br>
循环链表是一种特殊的单链表，它跟单链表唯一的区别就在尾结点，单链表的尾结点指针指向空地址，循环链表的尾结点指针是指向链表的头结点。   
循环链表的优点是从链尾到链头比较方便。   
双向链表：它支持两个方向，每个结点还有一个前驱指针prev指向前面的结点。  
 <div align="center"> <img src="pic/cbc8ab20276e2f9312030c313a9ef70b.jpg" width=""/> </div><br>  
                
##### 1.2 如何实现LRU缓存淘汰算法?最近最少使用策略 LRU（Least Recently Used）           
我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。   
如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 
如果此数据没有在缓存链表中，又可以分为两种情况：   
如果此时缓存未满，则将此结点直接插入到链表的头部；   
如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。                 
  
##### 1.3 如何正确的写出链表代码?
1. 技巧一：理解指针或引用的含义 
指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。p->next=q。这行代码是说,p结点中的next指针存储了q结点的内存地址。
2. 技巧二：警惕指针丢失和内存泄漏 
插入结点时，一定要注意操作的顺序，先保存指针指向。删除链表结点时，也一定要记得手动释放内存空间
3. 技巧三：利用哨兵简化实现难度 
引入哨兵结点不存储数据，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。 这个可以是一些资料深入理解
4. 技巧四：重点留意边界条件处理 
比如： 链表是否为空， 只包含一个，两个节点，处理的头结点，尾节点 。 
5. 多画图，多看题
练习题LeetCode对应编号：206，141，21，19，876                                 
#### 第四章：栈：如何实现浏览器的前进和后退功能？
后进者先出，先进者后出，这就是典型的“栈”结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。  
栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
 ````
     // 基于数组实现的顺序栈
     public class ArrayStack {
       private String[] items;  // 数组
       private int count;       // 栈中元素个数
       private int n;           // 栈的大小     
       // 初始化数组，申请一个大小为 n 的数组空间
       public ArrayStack(int n) {
         this.items = new String[n];
         this.n = n;
         this.count = 0;
       }
       // 入栈操作
       public boolean push(String item) {
         // 数组空间不够了，直接返回 false，入栈失败。
         if (count == n) return false;
         // 将 item 放到下标为 count 的位置，并且 count 加一
         items[count] = item;
         ++count;
         return true;
       } 
       // 出栈操作
       public String pop() {
         // 栈为空，则直接返回 null
         if (count == 0) return null;
         // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
         String tmp = items[count-1];
         --count;
         return tmp;
       }
     }
````                             
                            




## 第二部分：面试宝典算法题
### 第一部分 链表
````
链表结构:class Node{
                 Node next =null;
                 int data;
                 public Node(int data){this.data=data;}
}
````
1 [单链表的操作](https://github.com/princesslhb/Interview-2018-forever/blob/master/docs/data/链表.md)

 
 

