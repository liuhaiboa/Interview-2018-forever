# 冒泡排序（Bubble Sort）
冒泡排序只会操作相邻的两个数据，每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。  
是一个原地排序算法。冒泡排序是稳定的排序算法。  
最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。                                                          
经过一次冒泡操作之后，最大的数在最后
````$xslt
public void bolleanSort() {
        int temp;
        for(int i=0;i<arr.length-1;i++){
            for(int y=0;y<arr.length-1-i;y++){
                if(arr[y]>arr[y+1]){
                    temp=arr[y];
                    arr[y]=arr[y+1];
                    arr[y+1]=temp;
                }
            }
        }
        printArray(arr);//打印数组
    }
````
优化：
当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。
<div align="center"> <img src="../pic/bullenSort.jpg" width=""/> </div><br>

 ````$xslt
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}

````  
                           
 
有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：有序元素对：a[i] <= a[j], 如果 i < j。  
对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。  
逆序度的定义正好跟有序度相反，逆序度 = 满有序度 - 有序度。排序过程是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排排序完成了。

# 插入排序（Insertion Sort）                                                                                                             
 我们将数组中的数据分为两个区间，已排序区间和未排序区间。  
 初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。  
 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。这是一个原地排序算法。插入排序是稳定的排序算法。  
 时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。
                                                             
 ````$xslt
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}

````         
# 选择排序（Selection Sort）
每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
是一种原地排序算法，不稳定的排序算法。
````$xslt
 public void selctSort() {
       int min;
       int a=arr.length;
       int temp;
       for(int i=0;i<a;i++){
               min=i;
               for(int j=i+1;j<a;j++){//找出最小值每次
                   if(arr[j]<arr[min]){
                       min=j;
                   }
               }
               temp = arr[min];
               arr[min] = arr[i];
           arr[i] = temp;

       }
        printArray(arr);//打印数组
    }

````
  
          
<div align="center"> <img src="../pic/sortsort.jpg" width=""/> </div><br>


# 归并排序（Merge Sort）。
思想：先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，
总结：归并排序是一个稳定的排序算法。不管是最好情况、最坏情况，还是平均情况时间复杂度都是 O(nlogn)。归并排序不是原地排序算法。空间复杂度为 O(n)。  


# 快速排序算法（Quicksort）
快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。

# 希尔排序
通过将比较的全部元素分为几个区域来提升插入排序的性能。  


# 我自己总结的算法博客： https://blog.csdn.net/lettyisme/article/details/79753365

# 线性排序：时间复杂度O(n) 的排序算法：桶排序、计数排序、基数排序。
## 桶排序（Bucket sort）
核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。  
桶排序的时间复杂度是 O(n)。  
对要排序数据的要求是非常苛刻的：首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。
桶排序比较适合用在外部排序中，所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。  
借助桶排序的处理思想来解决这个问题：
我们可以先扫描一遍文件， 看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是1元，最大是10万元。我们将所有订单根据金额划分到100个桶里，第一个桶我们存储金额在1元到1000元之内的订单，第二桶存储金额在1001元到2000元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。  
理想的情况下，如果订单金额在1到10万之间均匀分布，那订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，我们就可以将这100个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中。的订单数据，并将其写入到一个文件中，，那这个文件中存储的就是按照金额从小到大排序的订单数据了。  
不过，你可能也发现了，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。针对这些划分之后还是比较大的文件，我们可以继续划分。

                                                                                       
# 计数排序（Counting sort）
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。
例子：如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次？  
考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。  
计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  
                                                                                                   
# 基数排序（Radix sort）
  基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。。除此之外，每一位的数据范围不能太大， 要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。
                                                                                                
                                                                                                                                                                                   